<h1 align="center"><a href="https://github.com/xkcoding" target="_blank">事务隔离级别代码演示</a></h1>


## 项目简介

`Transaction Isolation Level` 正如项目的名字一样，事务隔离级别，在我们学习数据库时，事务的隔离级别已经老生长谈，面试也是必考知识点，然而在学习的时候，我们基本上全都是在背概念，或者有的良心老师，也会给我们演示隔离级别，但是我们背的概念，或者别人的演示基本都是基于数据库的操作，而不是spring的代码操作。所以作者以自我学习为目的创建本项目，并且也希望分享给大家，能做从代码的层面感受事务隔离级别的真实后的状况。

## 开发环境

- **JDK 1.8 +**
- **Maven 3.5 +**
- **IntelliJ IDEA ULTIMATE 2018.2 +** (*注意：务必使用 IDEA 开发，同时保证安装 `lombok` 插件*)
- **Mysql 5.7 +** (*尽量保证使用 5.7 版本以上，因为 5.7 版本加了一些新特性，同时不向下兼容。本 demo 里会尽量避免这种不兼容的地方，但还是建议尽量保证 5.7 版本以上*)

## 数据库配置

- 推荐使用docker直接run一个mysql，本测试环境后期考虑放制作一个docker镜像，目前先把整体代码完成

## 运行方式

1. `git clone https://github.com/HolleQH/transaction-isolation-level.git`
2. 使用 IDEA 打开 clone 下来的项目
3. 在 IDEA 中 Maven Projects 的面板导入项目根目录下 的 `pom.xml` 文件
4. Maven Projects 找不到的童鞋，可以勾上 IDEA 顶部工具栏的 View -> Tool Buttons ，然后 Maven Projects 的面板就会出现在 IDEA 的右侧
5. 找到 test 下的各个测试类 类就可以运行了，每个测试demo可以通过查看控制台日志输出看到各种隔离级别发生的具体现象
7. **`注意：运行各个 demo 之前，需要事先初始化数据库数据的，亲们别忘记了哦~`**


##具体解释

###脏读
> 一个线程读取到了另外线程没有提交的事务

####脏读思路
>测试思路：总共开三个线程，
线程一：正常线程，开启事务更新后，事务提交后，分别读取两次值
线程二：脏读线程，开启事务更新后，事务提交后，分别读取两次值
线程三：开启事务，默认隔离级别，更新当前值为需要的值

####现象解读
- 更新线程 更新前读取数据name：4，开始准备将数据更新为：87
- 更新线程 将数据更新为：87，但是还没有提交
- 读未提交线程 更新后读取数据name：87 **_(出现脏读)_**
- 普通线程 更新后读取数据name：4
- 更新线程 提交事务->->->->->->->->
- 更新线程 结束
- 读未提交线程 提交后读取数据name：87
- 普通线程 提交后读取数据name：4 **_（ 数据库默认隔离级别，可重复读，所以数据不会变）_**
- 普通线程 结束
- 读未提交线程 结束

####脏读产生的坑
> 本来以为这个问题很简单，简单的跑两个线程测下就可以了，没想到这么坑
> 首先一个线程写，一个线程读没问题，读的线程读到写线程没有提交的事务就验证成功了，但是经过反复测试，发现了一个问题
> 就是读线程开启事务的时机必须在写线程执行写操作之后，如果在写线程之前就开启了读线程的事务，是不会发生脏读这个现象的
