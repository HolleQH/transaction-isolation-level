事务隔离级别演示
<h1 align="center"><a href="https://github.com/xkcoding" target="_blank">事务隔离级别代码演示</a></h1>

## 项目简介

`Transaction Isolation Level`
正如项目的名字一样，事务隔离级别，在我们学习mysql数据库时，事务的隔离级别已经老生长谈，面试也是必考知识点，然而在学习的时候，我们基本上全都是在背概念，并没有实际的设身处地感受到不同隔离级别产生的不同现象。所以作者以自我学习为目的创建本项目，并且也希望分享给大家，能做从代码的层面感受事务隔离级别的真实状况。

## 开发环境

- **JDK 1.8 +**
- **Maven 3.5 +**
- **IntelliJ IDEA ULTIMATE 2020.3 +** (*注意：务必使用 IDEA 开发，同时保证安装 `lombok` 插件*)
- **Mysql 5.7 +** (*尽量保证使用 5.7 版本以上，因为 5.7 版本加了一些新特性，同时不向下兼容。本 demo 里会尽量避免这种不兼容的地方，但还是建议尽量保证 5.7 版本以上*)

## 数据库配置

- 非常简单就一个user表，数据库脚本放在了resource/sql下

## 运行方式

1. `git clone https://github.com/HolleQH/transaction-isolation-level.git`
2. 使用 IDEA 打开 clone 下来的项目
3. 在 IDEA 中 Maven Projects 的面板导入项目根目录下 的 `pom.xml` 文件
4. Maven Projects 找不到的童鞋，可以勾上 IDEA 顶部工具栏的 View -> Tool Buttons ，然后 Maven Projects 的面板就会出现在 IDEA 的右侧
5. 找到 test 下的 **TransactionTests** 测试类 类就可以运行了，每个测试demo可以通过查看控制台日志输出看到各种隔离级别发生的具体现象
6. **`注意：运行各个 demo 之前，需要事先初始化数据库数据的，亲们别忘记了哦~`**

### 具体解释

### 脏读
> 一个线程读取到了另外线程没有提交的事务

####脏读思路

- 普通线程：正常线程，开启事务更新后，事务提交后，分别读取两次值
- 读未提交线程：脏读线程，开启事务更新后，事务提交后，分别读取两次值
- 更新线程：开启事务，默认隔离级别，更新当前值为需要的值

####现象解读

- 更新线程 更新前读取数据name：123，开始准备将数据更新为：59
- 更新线程 将数据更新为：59，但是还没有提交
- 读未提交线程 更新后读取数据name：59  **_(发生了脏读)_**
- 普通线程 更新后读取数据name：123
- 更新线程 提交事务->->->->->->->->
- 更新线程 结束
- 读未提交线程 提交后读取数据name：59
- 普通线程 提交后读取数据name：59
- 普通线程 结束
- 读未提交线程 结束

### 不可重复读

> 一个线程读到了其他事务提交的数据
> 测试方法：com.qh.transactionisolationlevel.TransactionTest.readCommit

#### 现象解读

- RC线程 开启事务
- RR线程 开启事务
- 更新线程 ：开启事务
- 更新线程 更新前读取数据name：1，开始准备将数据更新为：69
- 更新线程 将数据更新为：69，但是还没有提交
- RR线程 更新后读取数据name：1 _**（避免了脏读）**_
- RC线程 更新后读取数据name：1 _**（避免了脏读）**_
- 更新线程 提交事务->->->->->->->->
- 更新线程 结束
- RC线程 提交后读取数据name：69 _**（RC 发生了不可重读读）**_
- RR线程 提交后读取数据name：1 _**（RR 避免了不可重复）**_
- RR线程 结束
- RC线程 结束

> RC线程和RR线程在数据更新但是没有提交之前都避免了脏读现象 RC线程在数据提交后后，读出了最新的值，可见RC是当前读，可以读出其他线程提交的记录 RR线程在数据提交后仍然读出了老的值，解决了不可重复读问题，可见RR是快照读，第一次读取会生成一个快照，具体可以参考mysql的mvcc机制

#### 内容扩展

> 通过上面的现象了解了RR是快照读，避免了不可重复读现象，
> 但是如果RR线程要更新这个值对应的记录，也会读取到最新的值（可以参考测试类com.qh.transactionisolationlevel.TransactionTests.readCommit2）

#### 现象

- RC线程 开启事务
- RR线程 开启事务
- 更新线程 ：开启事务
- 更新线程 更新前读取数据name：65，开始准备将数据更新为：30
- 更新线程 将数据更新为：30，但是还没有提交
- RC线程 更新后读取数据name：65
- RR线程 更新后读取数据name：65
- 更新线程 提交事务->->->->->->->->
- 更新线程 结束
- RR线程 提交后读取数据name：65
- RC线程 提交后读取数据name：30
- RR线程 对数据进行更新 _**（进行更新）**_
- RC线程 结束
- RR线程 对数据进行更新后再次读取name：30 _**（发生了当前读）**_
- RR线程 结束

### 幻读

> 在RR级别下，解决了一部分的幻读问题，这个一部分到底是指的什么，通过接下来的测试类演示给读者 com.qh.transactionisolationlevel.TransactionTest.RepeatableRead

#### 现象解读

- RC线程 开启事务
- RR线程 开启事务
- 线程三 ：开启事务
- 线程三 更新前读取数据条数：4，开始准备新增一条数据
- 线程三 新增了一条数据，但是还没有提交
- RC线程 更新后读取数据条数：4
- RR线程 更新后读取数据条数：4
- 线程三 提交事务->->->->->->->->
- 线程三结束
- RR线程 提交后读取数据条数：4 _**（RR级别避免了幻读）**_
- RC线程 提交后读取数据条数：5 _**（RC级别发生了幻读）**_
- 线程一结束
- 线程二结束

> 从输出日志看出RR级别避免了幻读现象
> 然后执行测试2（com.qh.transactionisolationlevel.TransactionTest.RepeatableRead2）

#### 现象解读

- RR线程 开启事务
- 更新线程 ：开启事务
- 更新线程 更新前读取数据条数：5，开始准备新增一条数据
- 更新线程 新增了一条数据，但是还没有提交
- RR线程 更新后读取数据条数：5
- 更新线程 提交事务->->->->->->->->
- 更新线程 结束
- RR线程 提交后读取数据条数：5 _**（暂时还没发生幻读）**_
- RR线程 对某一条数据进行更新
- RR线程 对指定数据更新后读取数据条数：5 _**（还没有发生幻读）**_
- RR线程 对多条数据进行更新
- RR线程 对多条数据更新后读取数据条数：6 _**（发生幻读）**_
- RR线程 结束

> 从现象可以看出，在没有发生修改或者修改指定某确定的一条数据的时候，都避免的幻读现象
> 但是在修改多条记录的时候，会触发当前读，发生幻读现象

### 序列化

> 基本不会使用到的一种隔离级别，从现象可以看出，一开启事务的线程还没有结束，另一个线程修改记录，就会被阻塞住

